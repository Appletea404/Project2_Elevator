///*
// * fnd.c
// *
// *  Created on: Jan 29, 2026
// *      Author: appletea
// */
//
//

#include "fnd.h"

/* =======================
 *  Digit polarity (FIXED)
 *  ======================= */
#define DIG_ON   GPIO_PIN_RESET   // common-cathode via driver -> usually LOW = ON
#define DIG_OFF  GPIO_PIN_SET

/* =======================
 *  7-seg letter patterns (approx.)
 *  bit0=a, bit1=b, bit2=c, bit3=d, bit4=e, bit5=f, bit6=g
 *  ======================= */
#define SEG_A  0x77
#define SEG_d  0x5E
#define SEG_Y  0x6E



/* 0~9 segment patterns */
static const uint8_t FND_NUMBER[10] = {
    0x3F, 0x06, 0x5B, 0x4F, 0x66,
    0x6D, 0x7D, 0x27, 0x7F, 0x67
};
//
///* Segment pin indices (a~g order) */
//static const uint8_t SEG_INDEX[7] = {0, 1, 2, 3, 5, 8, 9};
//
///* Digit pin indices (DIG1~DIG4 order) */
//static const uint8_t DIG_INDEX[4] = {4, 6, 7, 10};
//
///* Display buffer (4 digits) : each item is a 7-bit segment pattern */
//static volatile uint8_t g_disp[4] = {0, 0, 0, 0};
//
//
///* =======================
// *  Low-level helpers
// *  ======================= */
//static void Seg_Write(uint8_t pat)
//{
//    for (int i = 0; i < 7; i++)
//    {
//        GPIO_PinState st = (pat & (1u << i)) ? FNDLed[SEG_INDEX[i]].onState
//                                             : FNDLed[SEG_INDEX[i]].offState;
//
//        HAL_GPIO_WritePin(FNDLed[SEG_INDEX[i]].port,
//                          FNDLed[SEG_INDEX[i]].number,
//                          st);
//    }
//}
//
//static void Dig_AllOff(void)
//{
//    for (int i = 0; i < 4; i++)
//    {
//        HAL_GPIO_WritePin(FNDLed[DIG_INDEX[i]].port,
//                          FNDLed[DIG_INDEX[i]].number,
//                          DIG_OFF);
//    }
//}
//
//static void Dig_On(uint8_t d) // 0~3
//{
//    HAL_GPIO_WritePin(FNDLed[DIG_INDEX[d]].port,
//                      FNDLed[DIG_INDEX[d]].number,
//                      DIG_ON);
//}
//
///* tiny delay to reduce ghosting */
//static inline void tiny_delay(void)
//{
//    for (volatile int i = 0; i < 80; i++) { __NOP(); }
//}
//
///* =======================
// *  Scan one step (call fast)
// *  ======================= */
//void FND_ScanOnce(void)
//{
//    static uint8_t scan = 0;
//
//    Dig_AllOff();
//    tiny_delay();
//
//    Seg_Write(g_disp[scan]);
//    tiny_delay();
//
//    Dig_On(scan);
//
//    scan = (scan + 1) & 0x03;
//}
//
///* =======================
// *  Contents
// *  ======================= */
//void DAY_1(void)
//{
//    g_disp[0] = SEG_d;
//    g_disp[1] = SEG_A;
//    g_disp[2] = SEG_Y;
//    g_disp[3] = FND2_NUMBER[1];
//}
//
//void DAY_2(void)
//{
//    g_disp[0] = SEG_d;
//    g_disp[1] = SEG_A;
//    g_disp[2] = SEG_Y;
//    g_disp[3] = FND2_NUMBER[2];
//}
//
//void DAY_3(void)
//{
//    g_disp[0] = SEG_d;
//    g_disp[1] = SEG_A;
//    g_disp[2] = SEG_Y;
//    g_disp[3] = FND2_NUMBER[3];
//}
//
//void DAY_4(void)
//{
//    g_disp[0] = SEG_d;
//    g_disp[1] = SEG_A;
//    g_disp[2] = SEG_Y;
//    g_disp[3] = FND2_NUMBER[4];
//}
//
///* 0~9 test: all digits show same number */
//void FND_Test_0to9_AllDigit(void)
//{
//    static uint32_t t = 0;
//    static uint8_t n = 0;
//
//    if (HAL_GetTick() - t >= 500)
//    {
//        t = HAL_GetTick();
//        n = (n + 1) % 10;
//
//        uint8_t pat = FND2_NUMBER[n];
//        g_disp[0] = pat;
//        g_disp[1] = pat;
//        g_disp[2] = pat;
//        g_disp[3] = pat;
//    }
//}
//
///* =======================
// *  Main API
// *  - Call this every 1ms (or faster) in main loop
 *  ======================= */
void FND_CONTROL(void)
{

}


